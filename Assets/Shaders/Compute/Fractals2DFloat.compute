/* Unfortunately some platforms (e.g. linux) don't support double precision on
compute shaders so this one is used instead. The code is exactly the same as
Fractals2D.compute so to see the docs open that file. */

#pragma kernel CSMain

#define MAX_DEGREE 10

RWTexture2D<float4> FractalTex;

float Size;
float CenterRe;
float CenterIm;

bool Julia;
float JuliaRe;
float JuliaIm;

bool Invert;

int MaxDegreeUsed;
float4 Coeficients[MAX_DEGREE];

int MaxIter;
int AntialiasingSamples;

int PaletteIndex;

float PseudorandomFloat(float2 seed)
{
    return frac(sin(dot(seed, float2(12.9898, 78.233))) * 43758.5453);
}

float4 pal(float t, float3 a, float3 b, float3 c, float3 d)
{
    float3 col = a + b * cos(6.28318 * (c * t + d));
    return float4(col.xyz, 1);
}

float4 calculateColor(uint iter)
{
    if (iter == MaxIter)
        return float4(0, 0, 0, 1);
    
    float3 vec1 = float3(1.0, 1.0, 1.0);
    float t = (float) (iter % 50) / 50 + 0.45f;
    
    if (PaletteIndex == 0)
    {
        return pal(t, vec1 / 2, vec1 / 2, vec1, float3(0.0, 0.10, 0.20));
    }

    return pal(t, vec1 / 2, vec1 / 2, vec1, float3(-0.86, 1.02, 1));
}

uint calculateIterations(float2 z, float2 add)
{
    for (uint i = 0; i < MaxIter; i++)
    {
        float2 lastZ = z;
        z = float2(0, 0);
        
        float2 powAcc = float2(1, 0);
        
        for (int j = 0; j < MAX_DEGREE; j++)
        {
            powAcc = float2(powAcc.x * lastZ.x - powAcc.y * lastZ.y, powAcc.x * lastZ.y + powAcc.y * lastZ.x);
            z += powAcc * Coeficients[j].x;
        }
        
        z += add;

        if (z.x * z.x + z.y * z.y > 4)
            return i;
    }
    return MaxIter;
}

[numthreads(8, 8, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    uint width;
    uint height;
    FractalTex.GetDimensions(width, height);
    
    float re = (float) id.x / height - 0.5 * (float) width / (float) height;
    float im = (float) id.y / height - 0.5;
    float2 coords = float2(re, im) * Size + float2(CenterRe, CenterIm);
    
    if (id.x < width && id.y < height)
    {
        float4 color = float4(0, 0, 0, 0);
        float2 realCoords = coords;
        
        for (int i = 0; i < AntialiasingSamples; i++)
        {
            coords = realCoords;
            
            float2 offset;
            if (i == 0)
                offset = float2(0, 0);
            else
                offset = float2(
                    PseudorandomFloat(float2(width + i, height + i)) * 2 - 1,
                    PseudorandomFloat(float2(height + 2 * i, width - 2 * i)) * 2 - 1
                );
            
            float pixelSize = Size / (float) height;
            coords += offset * pixelSize / 2;
            
            if (Invert)
            {
                float denominator = coords.x * coords.x + coords.y * coords.y;
                coords = float2(coords.x / denominator, -coords.y / denominator);
            }

            uint iterations = calculateIterations(!Julia ? 0 : coords, !Julia ? coords : float2(JuliaRe, JuliaIm));
            color += calculateColor(iterations);
        }
        
        FractalTex[id.xy] = color / AntialiasingSamples;
    }
}